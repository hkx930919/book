---
sidebarDepth: 2
---

# 浏览器工作原理

## 宏观视角下的浏览器

### 1.1 chrome 架构

#### 进程和线程

**并行处理：**计算机中的并行处理就是同一时刻处理多个任务

> 有多个任务要处理时，正常情况下程序可以使用单线程来处理，也就是分步按照顺序分别执行这些任务。如果采用多线程，多个线程同
> 时执行这些任务；使用并行处理能大大提升性能

- 线程不能单独存在，它是由进程进行启动和管理，线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率

- 一个进程就是一个程序的运行实例。启动一个程序的时候，操作系统会为该 程序创建一块内存，用来存放代码、运行中的数据和一个
  执行任务的主线程，我们把这样的 一个运行环境叫进程
- 进程中的任意一线程执行出错，都会导致整个进程的崩溃
- 线程之间共享进程中的数据
- 当一个进程关闭之后，操作系统会回收进程所占用的内存
- 进程之间的内容相互隔离。一个进程挂了不会影响到别的进程，进程与进程之前使用 IPC 进行通信

#### 单进程浏览器时代

> 单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、 JavaScript 运行环境、渲染引擎和
> 页面等。

如此多的功能模块运行在一个进程里，是导致单进程浏览器不稳定、不流畅和不安全的一个主要因素

- **不稳定：**线程的崩溃导致进程的崩溃，进而整个浏览器崩溃
  - 插件的崩溃导致整个浏览器的崩溃
  - 渲染引擎模块也是不稳定的，一些复杂的 JavaScript 代码就有可能引起渲染引擎模块的崩溃，进而导致浏览器崩溃
- **不流畅：**所有页面的渲染模块、JavaScript 执行 环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块
  可以执行，js 会阻塞其他模块的进行
- **不安全：**插件可以使用 C/C++ 等代码编写，通过插件可以获取到操作系统的任意资源，当你在页面 运行一个插件时也就意味着这
  个插件能完全操作你的电脑。如果是个恶意插件，那么它就可 以释放病毒、窃取你的账号密码，引发安全性问题

#### 多进程浏览器时代

##### 早期多进程架构

![早期 Chrome 进程架构图 ](./images/brower/chrome-before-frame.png) <br/>包含渲染进程、插件进程、浏览器主进程，每个 tab
页和一个插件就是一个新的进程

- **不稳定解决方案：**由于进程是相互隔离的，所以当一个页面或者插件崩溃 时，影响到的仅仅是当前的页面进程或者插件进程，并
  不会影响到浏览器和其他页面，这就 完美地解决了页面或者插件的崩溃会导致整个浏览器崩溃
- **不流畅解决方案：**
  - 同样，JavaScript 也是运行在渲染进程中 的，所以即使 JavaScript 阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会
    影响浏览器其他页面，因为其他页面的脚本是运行在它们自己的渲染进程中的。
  - 当关闭一个页面时，整个渲染进程也会被关 闭，之后该进程所占用的内存都会被系统回收，这样就轻松解决了浏览器页面的内存 泄
    漏问题。
- **不安全解决方案：**对插件进程和渲染进程使用**安全沙箱**，可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以
  运行， 但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据，这样即使在渲染进程或者插件进程里 面执行了恶意程
  序，恶意程序也无法突破沙箱去获取系统权限。

##### 目前多进程架构

![目前多进程架构 ](./images/brower/chrome-current-frame.png) <br/>在之前的基础上增加了 GPU 进程和网络进程。

- **浏览器主进程。**主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
- **渲染进程。**核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8
  都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
- **GPU 进程。**Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页
  、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU
  进程。
- **网络进程。**主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的
  进程。负责 http 的请求
- **插件进程进程。**主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面
  造成影响。

  所以打开一个页面，至少会开启浏览器主进程、渲染进程、GPU 进程、网络进程这四个进程，如果装了插件，那么每个插件都算一个进
  程。

<br/>多进程也有一些弊端：

- **更高的资源占用：**因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存
  资源。
- **更复杂的体系架构：**浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。

##### 未来面向服务的架构

为了解决这些问题，在 2016 年，Chrome 官方团队使用“面向服务的架构”（Services Oriented Architecture，简称 SOA）的思想设计
了新的 Chrome 架构。也就是说 Chrome 整体架构会朝向现代操作系统所采用的“面向服务的架构” 方向发展，原来的各种模块会被重构
成独立的服务（Service），每个服务（Service）都可以在独立的进程中运行，访问服务（Service）必须使用定义好的接口，通过 IPC
来通信，从而构建一个**更内聚、松耦合、易于维护和扩展的系统**，更好实现 Chrome 简单、稳定、高速、安全的目标。
![未来面向服务的架构 ](./images/brower/chrome-futrue-frame.png)

#### TIPS

- Q:为什么还会碰到一些由于单个页面卡死最终崩溃导致所有页面崩溃的情况？

```
有一种情况，叫"同一站点(same-site)"，具体地讲，我们将“同一站点”定义为根域名（例如，geekbang.org）加上协议（例如，https:// 或者http://），还包含了该根域名下的所有子域名和不同的端口，比如下面这三个：
https://time.geekbang.org
https://www.geekbang.org
https://www.geekbang.org:8080
都是属于同一站点，因为它们的协议都是https，而根域名也都是geekbang.org。

Chrome的默认策略是，每个标签对应一个渲染进程。但是如果从一个页面打开了新页面，而新页面和当前页面属于同一站点时，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫process-per-site-instance。即统一站点的页面共用一个渲染进程。

为什么要让他们跑在一个进程里面呢？
因为在一个渲染进程里面，他们就会共享JS的执行环境，也就是说A页面可以直接在B页面中执行脚本。因为是同一家的站点，所以是有这个需求的。
```

- Q:为什么打开一个页面后没有插件也不只四个进程？

```
如果页面里有iframe的话，iframe也会运行在单独的进程中！
```

- Q:Chrome 排版引擎现在是 blink，这一点从哪里可以看到呢？在 76 版本 Chrome 的 navigator 属性值里只看到了 AppleWebkit，这
  是为什么？

```
UserAgent，又称为UA，UA是浏览器的身份证，通常，在发送HTTP请求时，UA会附带在HTTP的请求头中user-agent字段中，这样服务器就会知道浏览器的基础信息，然后服务器会根据不同的UA返回不同的页面内容，比如手机上返回手机的样式，PC就返回PC的样式。

服务器会根据不同的UA来针性的设计不同页面，所以当出了一款新浏览器时，他如果使用自己独一无二的UA，那么之前的很多服务器还需要针对他来做页面适配，这显然是不可能的，比如Chrome发布时他会在他的UA中使用“Mozilla” ，“AppleWebKit”，等关键字段，用来表示他同时支持Mozilla和AppleWebKit，然后再在最后加上他自己的标示，如Chrome/xxx。

这就解释了为什么查看的信息中含有WebKit字样。
```

- 安全沙箱是不能应用到浏览器主进程之上的，因为浏览器主进程需要对操作系统的权限

### 1.2 http

浏览器展示页面，离不开 http 协议，而 http 是基于 tcp 的应用层协议，而 tcp 基于 ip

#### IP

数据包要在互联网上进行传输，就要符合网际协议（Internet Protocol，简称 IP）标准。互联网上不同的在线设备都有唯一的地址，地
址只是一个数字，这个地址就是 IP。

**计算机的地址就称为 IP 地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息**

<p>把一个数据包从主机 A 发送给主机 B，简单的三层网络模型</p>

> IP 头是 IP 数据包开头的信息，包含 IP 版本、源 IP 地址、目标 IP 地址、生存时间等信息。

![简单的三层网络模型](./images/brower/network-frame.png)

- 上层将含有“极客时间”的数据包交给网络层；
- 网络层再将 IP 头附加到数据包上，组成新的 IP 数据包，并交给底层；
- 底层通过物理网络将数据包传输给主机 B；
- 数据包被传输到主机 B 的网络层，在这里主机 B 拆开数据包的 IP 头信息，并将拆开来的数据部分交给上层；
- 最终，含有“极客时间”信息的数据包就到达了主机 B 的上层了。

#### UDP

IP 是非常底层的协议，只负责把数据包传送到对方电脑，但是对方电脑并不知道把数据包交给哪个程序，是交给浏览器还是交给英雄联
盟？因此，需要基于 IP 之上开发能和应用打交道的协议，最常见的是“用户数据包协议（User Datagram Protocol）”，简称 UDP。

UDP 中一个最重要的信息是端口号，端口号其实就是一个数字，每个想访问网络的程序都需要绑定一个端口号。

**所以 IP 通过 IP 地址信息把数据包发送给指定的电脑，而 UDP 通过端口号把数据包分发给正确的程序**。和 IP 头一样，端口号会
被装进 UDP 头里面，UDP 头再和原始数据包合并组成新的 UDP 数据包。UDP 头中除了目的端口，还有源端口号等信息。

![简化的 UDP 网络四层传输模型](./images/brower/udp-frame.png)

下面我们一起来看下一个数据包从主机 A 旅行到主机 B 的路线：

- 上层将含有“极客时间”的数据包交给传输层；
- 传输层会在数据包前面附加上 UDP 头，组成新的 UDP 数据包，再将新的 UDP 数据包交给网络层；
- 网络层再将 IP 头附加到数据包上，组成新的 IP 数据包，并交给底层；
- 数据包被传输到主机 B 的网络层，在这里主机 B 拆开 IP 头信息，并将拆开来的数据部分交给传输层；
- 在传输层，数据包中的 UDP 头会被拆开，并根据 UDP 中所提供的端口号，把数据部分交给上层的应用程序；
- 最终，含有“极客时间”信息的数据包就旅行到了主机 B 上层应用程序这里。

#### TCP

UDP 存在以下不足：

- 数据包在传输过程中容易丢失；
- 大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而 UDP 协议并不知道如
  何组装这些数据包，从而把这些数据包还原成完整的文件。

基于这两个问题，引入 TCP（Transmission Control Protocol，传输控制协议），它是一种面向连接的、可靠的、基于字节 流的传输层
通信协议。相对于 UDP，TCP 有下面两个特点:

- 对于数据包丢失的情况，TCP 提供重传机制；
- TCP 引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。

和 UDP 头一样，TCP 头除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，以便接收端通过序号来重排数据包。

![简化的 TCP 网络四层传输模型](./images/brower/tcp-frame.png)

一个完整的 TCP 连接的生命周期包括了“建立连接”“传输数据”和“断开连接”三个阶段。

##### TCP 建立连接

三次握手建立连接 ![三次握手](./images/brower/tcp-connect.jpg)

- 第一次握手： 建立连接。客户端发送连接请求报文段，将 SYN 位置为 1，Sequence Number 为 x；然后，客户端进入 SYN_SEND 状态
  ，等待服务器的确认
- 第二次握手：服务器收到 SYN 报文段。服务器收到客户端的 SYN 报文段，需要对这个 SYN 报文段进行确认，设置 Acknowledgment
  Number 为 x+1(Sequence Number+1)；同时，自己还要发送 SYN 请求信息，将 SYN 位置为 1，Sequence Number 为 y；服务器端将上
  述所有信息放到一个报文段（即 SYN+ACK 报文段）中，一并发送给客户端，此时服务器进入 SYN_RECV 状态
- 第三次握手：客户端收到服务器的 SYN+ACK 报文段。然后将 Acknowledgment Number 设置为 y+1，向服务器发送 ACK 报文段，这个
  报文段发送完毕以后，客户端和服务器端都进入 ESTABLISHED 状态，完成 TCP 三次握手。

简单点讲就是：第一次握手：客户端向服务端发送连接请求；第二次握手：服务端确认连接，并向客户端发送连接请求；第三次握手：客
户端确认连接，三次握手成功

_为什么要三次握手？_

<p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误，所以有第三次客户端确认握手</p>

##### TCP 断开连接

![四次挥手](./images/brower/tcp-unconnect.jpg)

- 第一次挥手： 主机 1（可以使客户端，也可以是服务器端），设置 Sequence Number，向主机 2 发送一个 FIN 报文段；此时，主机
  1 进入 FIN_WAIT_1 状态；这表示主机 1 没有数据要发送给主机 2 了；

- 第二次挥手： 主机 2 收到了主机 1 发送的 FIN 报文段，向主机 1 回一个 ACK 报文段，Acknowledgment Number 为 Sequence
  Number 加 1；主机 1 进入 FIN_WAIT_2 状态；主机 2 告诉主机 1，我“同意”你的关闭请求；

- 第三次挥手： 主机 2 向主机 1 发送 FIN 报文段，请求关闭连接，同时主机 2 进入 LAST_ACK 状态；

- 第四次挥手： 主机 1 收到主机 2 发送的 FIN 报文段，向主机 2 发送 ACK 报文段，然后主机 1 进入 TIME_WAIT 状态；主机 2 收
  到主机 1 的 ACK 报文段以后，就关闭连接；此时，主机 1 等待 2MSL 后依然没有收到回复，则证明 Server 端已正常关闭，那好，
  主机 1 也可以关闭连接了。

简单点讲就是：因为 TCP 是全双工模式，所以断开连接时需要客户端和服务端都要发一次断开连接请求。第一次挥手：客户端发送断开
连接请求；第二次挥手：服务端发送同意断开连接请求给客户端；第三次挥手：服务端发送断开连接请求；第四次挥手：客户端发送同意
断开连接请求给服务端

- _为什么要四次挥手？_

<p>TCP 协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP 是全双工模式，这就意味着，当主机
1 发出 FIN 报文段时，只是表示主机 1 已经没有数据要发送了，主机 1 告诉主机 2，它的数据已经全部发送完毕了；但是，这个时候
主机 1 还是可以接受来自主机 2 的数据；当主机 2 返回 ACK 报文段时，表示它已经知道主机 1 没有数据发送了，但是主机 2 还是可
以发送数据到主机 1 的；当主机 2 也发送了 FIN 报文段时，这个时候就表示主机 2 也没有数据要发送了，就会告诉主机 1，我也没有
数据要发送了，之后彼此就会愉快的中断这次 TCP 连接。</p>

#### HTTP

**HTTP 协议，正是建立在 TCP 连接基础之上的，HTTP 是一种允许浏览器向服务器获取资源的协议，是 Web 的基础**

##### http 报文结构

http 报文分为请求报文和响应报文，它的结构分为：

- 通用头部
- 请求/响应头部
- 请求/响应体

以下对这些报文做详细分析：

1. 通用头部

```json
Request Url: 请求的web服务器地址
// http1.0 定义：get post head
// http1.1 新增五种：options put delete trace connect
Request Method: 请求方式（Get、POST、OPTIONS、PUT、HEAD、DELETE、CONNECT、TRACE）
Status Code: 请求的返回状态码，如200代表成功
Remote Address: 请求的远程服务器地址（会转为IP）
```

1.1 状态码

```
1XX-指示信息，代表请求已经收到，继续处理
2XX-成功，请求已被成功接收、理解、接收
3XX-重定向，
4XX-客户端出错，
5XX-服务器端出错
```

2. 请求头部（部分）

```
Accept: 接收类型，表示浏览器支持的MIME类型
（对标服务端返回的Content-Type）
Accept-Encoding：浏览器支持的压缩类型,如gzip等,超出类型不能接收
Content-Type：客户端发送出去实体内容的类型
Cache-Control: 指定请求和响应遵循的缓存机制，如no-cache
If-Modified-Since：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内，http1.0中
Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间
Max-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中
If-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中
Cookie: 有cookie并且同域访问时会自动带上
Connection: 当浏览器与服务器通信时对于长连接如何进行处理,如keep-alive（重复利用tcp）
Host：请求的服务器URL
Origin：最初的请求是从哪里发起的（只会精确到端口），Origin比Referer更尊重隐私
Referer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)
User-Agent：用户客户端的一些必要信息，如UA头部等
```

3. 响应头部(部分)

```
Access-Control-Allow-Headers: 服务器端允许的请求Headers
Access-Control-Allow-Methods: 服务器端允许的请求方法
Access-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*）
Content-Type：服务端返回的实体内容的类型
Date：数据从服务器发送的时间
Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档
Last-Modified：请求资源的最后修改时间
Expires：应该在什么时候认为文档已经过期,从而不再缓存它
Max-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效
ETag：请求变量的实体标签的当前值
Set-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端
Keep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38）
Server：服务器的一些相关信息
```

4.  请求头部和响应头部对应的字段

    - 请求头：Accept 响应头：Content-Type
    - 请求头：Origin 跨域 响应头：Access-Control-Allow-Origin
    - 请求头：If-Modified-Since 缓存 响应头：Last-Modified
    - 请求头：If-None-Match 缓存 响应头：ETag

5.  CRLF 意思是回车换行，一般作为分隔符存在

##### cookie

因为请求同域名的资源请求时，浏览器会默认带上本地的 cookie，针对这种情况，在某些场景下是需要优化的。 场景：

```
客户端在域名A下有cookie（这个可以是登陆时由服务端写入的）
然后在域名A下有一个页面，页面中有很多依赖的静态资源（都是域名A的，譬如有20个静态资源）
此时就有一个问题，页面加载，请求这些静态资源时，浏览器会默认带上cookie
也就是说，这20个静态资源的http请求，每一个都得带上cookie，而实际上静态资源并不需要cookie验证
此时就造成了较为严重的浪费，而且也降低了访问速度（因为内容更多了）
```

此时可以进行多域名拆分：

- 将静态资源分组，分别放到不同的域名下（如 static.base.com）
- 而 page.base.com（页面所在域名）下请求时，是不会带上 static.base.com 域名的 cookie 的，所以就避免了浪费。拆分成多域名
  时，在移动端会降低请求速度。因为域名整套解析流程是很耗费时间的，而且移动端一般带宽都比不上 pc，此时可以用 dns-prefetch
  进行优化（让浏览器空闲时提前解析 dns 域名，不过也请合理使用，勿滥用）

另外在本地开发时一种常见的利用 cookie 的情况就是借助 cookie 的 domain 属性，客服端和服务端只能设置该域名或者子域名下的
cookie，默认是页面所载域名。例如在`page.base.com`下可以设置`page.base.com`和 `base.com`的`cookie`，不能设
置`static.base.com`域名的`cookie`。而`static.base.com`可以获取`static.base.com base.com`下的`cookie`。所以在本地开发时通
常可以使用`test.page.base.com`的域名通过`hosts`文件修改指向本地，这样`test.page.base.com`可以拿
到`page.base.com base.com`的 `cookie`，获取网站的登录态

##### 长连接和短连接

tcp/ip 层面的定义：

- 长连接：一个 tcp/ip 连接上可以连续发送多个数据包，在 tcp 连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连
  接，一般需要自己做在线维持（类似于心跳包）
- 短连接：通信双方有数据交互时，就建立一个 tcp 连接，数据发送完成后，则断开此 tcp 连接
- http1.0：默认使用的是短连接，也就是说，浏览器每进行一次 http 操作，就建立一次连接，任务结束就中断连接，譬如每一个静态
  资源请求时都是一个单独的连接
- http1.1：默认使用的是长连接。使用长连接会有这一行 Connection: keep-alive，在长连接的情况下，当一个网页打开完成后，客户
  端和服务端之间用于传输 http 的 tcp 连接不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接

有些时候，`TCP` 建立连接和断开连接的时间就有可能`http`超过传输数据的时间了，这种短连接的效率是异常的低效。所以
在`http1.1`出现长连接来优化。但是使用 keep-alive 同样存在问题，比如一个页面可能有 100 张图片素材，假设这些图片素材都保存
在同一个域名下面，如果只复用一个 http 管道的话，那么传输 100 张图片的素材也是非常耗时间的。这就出现了同一时刻并发连接服
务器的需求，所以在 chrome 浏览器对同一域名下面，只能可以发起 6 个请求，这样就可以大大提升请求效率了。

#### http 缓存

http 缓存分为强缓存（200 from cache）和协商缓存(304)

##### 强缓存（200 from cache）

浏览器如果判断本地缓存未过期，就直接使用，无需发起 http 请求。如果已经过期，浏览器向服务器发送 http 请求，如果服务器内容
没有变化会返回 304 告诉浏览器使用缓存，如果文件已更新，返回新内容

- 属于强缓存控制的请求头：
  > http1.1:Cache-Control/Max-Age <br/> http1.0:Pragma/Expires

##### 协商缓存（304 from cache）

浏览器向服务器发送 http 请求验证是否失效（新鲜），如果没有失效服务端会返回 304，此时客户端直接从缓存中获取所请求的数据，
如果标识失效，服务端会返回更新后的数据。

- 属于协商缓存控制的请求头：
  > http1.1 If-None-Match/E-tag <br/> http1.0 If-Modified-Since/Last-Modified

在 html 页面使用*META HTTP-EQUIV="Pragma" CONTENT="no-cache"*也可以控制缓存，但是对缓存代理服务器不适用

##### 1.0 和 1.1 缓存的区别

- max-age 和 expires

  > **expires** 使用的是服务器时间。但是如果客户端时间和服务端不同步,那么缓存就会出现问题<br/> **max-age** 使用的是绝对
  > 时间由浏览器根据自己的时间+绝对值进行计算

  **如果同时开启了 Cache-Control 与 Expires，Cache-Control 优先级高。**

- E-tag 和 Last-Modified

  > Last-Modified

  - 表明服务端的文件最后何时改变的
  - 它有一个缺陷就是只能精确到 1s
  - 然后还有一个问题就是有的服务端的文件会周期性的改变，导致缓存失效

  > **E-tag**

  - 是一种指纹机制，代表文件相关指纹
  - 只有文件变才会变，也只要文件变就会变
  - 也没有精确时间的限制，只要文件一变，立马 E-tag 就不一样了

  **如果同时带有 E-tag 和 Last-Modified，服务端会优先检查 E-tag**

### 1.3 从输入 URL 到页面展示

![从输入 URL 到页面展示](./images/brower/url-to-render.png)

- 用户输入 url，判断是否是地址，是地址的话，组装协议，拼接成完成的 url
- 浏览器进程通过 IPC 发给网络进程，网络进程判断是否有缓存，有缓存就直接发送给浏览器进程，没有缓存则发送请求
- 发送请求前包含 DNS 解析获取 IP 地址，https 建立 tls 连接，建立 TCP 连接，最后发送 http 请求
- 服务器响应 URL 请求之后，浏览器进程就又要开始准备渲染进程了。如果响应了 301 302，那么重定向到响应的 location 字段地址
  ，发起 http 请求，从头开始。
- 渲染进程默认是一个 tab 一个渲染进程。当同一站点时，可能存在多个页面一个进程，但是当页面使用
  了`rel="noopener noreferrer"`，那么同一站点不会共用一个渲染进程，这个属性告诉浏览器，新打开的子窗口不需要访问父窗口的
  任何内容
- 渲染进程准备好之后，需要先向渲染进程提交页面数据，我们称之为提交文档阶段；
- 渲染进程接收完文档信息之后，便开始解析页面和加载子资源，完成页面的渲染。

#### 1 用户输入

当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是搜索内容，还是请求的 URL：

- 如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL。
- 如果判断输入内容符合 URL 规则，比如输入的是 time.geekbang.org，那么地址栏会根据规则，把这段内容加上协议，合成为完整的
  URL，如 https://time.geekbang.org。

当浏览器刚开始加载一个地址之后，标签页上的图标便进入了加载状态。但此时图中页面显示的依然是之前打开的页面内容，并没立即替
换为极客时间的页面。因为需要等待提交文档阶段，页面内容才会被替换。

#### 2 URL 请求过程

浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程，网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程。

- 首先，网络进程会查找本地缓存是否缓存了该资源。
  - 有缓存资源，那么直接返回资源给浏览器进程
  - 没有缓存，那么直接进入网络请求流程
- 进行 DNS 解析，以获取请求域名的服务器 IP 地址，如果请求协议是 HTTPS，那么还需要建立 TLS 连接。
- 利用 IP 地址和服务器建立 TCP 连接，经历 TCP3 次握手
- 连接建立之后，浏览器端发送 http 请求，会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后
  向服务器发送构建的请求信息。
- 服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收
  了响应行和响应头之后，就开始解析响应头的内容了。

##### 2.1 重定向

在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是 301 或者 302，那么说明服务器需要浏览器重定
向到其他 URL。这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重
头开始了。

##### 2.2 响应数据处理

浏览器会根据响应头的`Content-Type` 的值来决定如何显示响应体的内容，`Content-Type` 是 `HTTP` 头中一个非常重要的字段， 它
告诉浏览器服务器返回的响应体数据是什么类型。例如：

- Content-type： text/html，告诉浏览器服务器返回的数据是 HTML 格式，可以在页面上渲染
- Content-Type：application/octet-stream，字节流类型，浏览器会按照**下载类型**来处理该请求。

如果服务器配置 Content-Type 不正确，比如将 text/html 类型配置成 application/octet-stream 类型，那么浏览器可能会曲解文件
内容，比如会将一个本来是用来展示的页面，变成了一个下载文件。

##### 2.3 渲染进程

Chrome 的默认策略是，每个标签对应一个渲染进程。但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，
那么新页面会复用父页面的渲染进程。官方把这个默认策略叫 `process-per-site-instance`。若新页面和当前页面不属于同一站点，那
么新页面会使用一个新的渲染进程。

> 同一站点：根域名加上协议相同即是同一站点。<br/> >
> `https://time.static.org https://www.static.org https://www.static.org:8080`这三个为同一站点，他们的协议都是`https`，
> 根域名都是`static.org`,端口号的差异不是判断同一站点的根据。

有个例外，当打开新页面的标签页使用`<a target="_blank" rel="noopener noreferrer" href="xxx" >xxx</a>`包
含`rel="noopener noreferrer"`属性，那么同一站点不会共用一个渲染进程，这个属性告诉浏览器，新打开的子窗口不需要访问父窗口
的任何内容。浏览器在打开新页面时，解析到含有 `noopener noreferrer` 时，就知道他们不需要共享页面内容，所以这时候浏览器就
会让新链接在一个新页面中打开了。

##### 2.4 提交文档

这里的“文档”是指 URL 请求的响应体数据。

- “提交文档”的消息是由浏览器进程发出的，渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”。
- 等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程。
- 浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web
  页面。

这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。

#### 3 渲染流程
