---
sidebarDepth: 2
---

# 浏览器工作原理

## 宏观视角下的浏览器

### 1.1 chrome 架构

#### 进程和线程

**并行处理：**计算机中的并行处理就是同一时刻处理多个任务

> 有多个任务要处理时，正常情况下程序可以使用单线程来处理，也就是分步按照顺序分别执行这些任务。如果采用多线程，多个线程同
> 时执行这些任务；使用并行处理能大大提升性能

- 线程不能单独存在，它是由进程进行启动和管理，线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率

- 一个进程就是一个程序的运行实例。启动一个程序的时候，操作系统会为该 程序创建一块内存，用来存放代码、运行中的数据和一个
  执行任务的主线程，我们把这样的 一个运行环境叫进程
- 进程中的任意一线程执行出错，都会导致整个进程的崩溃
- 线程之间共享进程中的数据
- 当一个进程关闭之后，操作系统会回收进程所占用的内存
- 进程之间的内容相互隔离。一个进程挂了不会影响到别的进程，进程与进程之前使用 IPC 进行通信

#### 单进程浏览器时代

> 单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、 JavaScript 运行环境、渲染引擎和
> 页面等。

如此多的功能模块运行在一个进程里，是导致单进程浏览器不稳定、不流畅和不安全的一个主要因素

- **不稳定：**线程的崩溃导致进程的崩溃，进而整个浏览器崩溃
  - 插件的崩溃导致整个浏览器的崩溃
  - 渲染引擎模块也是不稳定的，一些复杂的 JavaScript 代码就有可能引起渲染引擎模块的崩溃，进而导致浏览器崩溃
- **不流畅：**所有页面的渲染模块、JavaScript 执行 环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块
  可以执行，js 会阻塞其他模块的进行
- **不安全：**插件可以使用 C/C++ 等代码编写，通过插件可以获取到操作系统的任意资源，当你在页面 运行一个插件时也就意味着这
  个插件能完全操作你的电脑。如果是个恶意插件，那么它就可 以释放病毒、窃取你的账号密码，引发安全性问题

#### 多进程浏览器时代

##### 早期多进程架构

![早期 Chrome 进程架构图 ](https://static001.geekbang.org/resource/image/cd/60/cdc9215e6c6377fc965b7fac8c3ec960.png)
<br/>包含渲染进程、插件进程、浏览器主进程，每个 tab 页和一个插件就是一个新的进程

- **不稳定解决方案：**由于进程是相互隔离的，所以当一个页面或者插件崩溃 时，影响到的仅仅是当前的页面进程或者插件进程，并
  不会影响到浏览器和其他页面，这就 完美地解决了页面或者插件的崩溃会导致整个浏览器崩溃
- **不流畅解决方案：**
  - 同样，JavaScript 也是运行在渲染进程中 的，所以即使 JavaScript 阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会
    影响浏览器其他页面，因为其他页面的脚本是运行在它们自己的渲染进程中的。
  - 当关闭一个页面时，整个渲染进程也会被关 闭，之后该进程所占用的内存都会被系统回收，这样就轻松解决了浏览器页面的内存 泄
    漏问题。
- **不安全解决方案：**对插件进程和渲染进程使用**安全沙箱**，可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以
  运行， 但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据，这样即使在渲染进程或者插件进程里 面执行了恶意程
  序，恶意程序也无法突破沙箱去获取系统权限。

##### 目前多进程架构

![目前多进程架构 ](https://static001.geekbang.org/resource/image/b6/fc/b61cab529fa31301bde290813b4587fc.png) <br/>在之前
的基础上增加了 GPU 进程和网络进程。

- **浏览器主进程。**主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
- **渲染进程。**核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8
  都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
- **GPU 进程。**Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页
  、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU
  进程。
- **网络进程。**主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的
  进程。负责 http 的请求
- **插件进程进程。**主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面
  造成影响。

  所以打开一个页面，至少会开启浏览器主进程、渲染进程、GPU 进程、网络进程这四个进程，如果装了插件，那么每个插件都算一个进
  程。

<br/>多进程也有一些弊端：

- **更高的资源占用：**因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存
  资源。
- **更复杂的体系架构：**浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。

##### 未来面向服务的架构

为了解决这些问题，在 2016 年，Chrome 官方团队使用“面向服务的架构”（Services Oriented Architecture，简称 SOA）的思想设计
了新的 Chrome 架构。也就是说 Chrome 整体架构会朝向现代操作系统所采用的“面向服务的架构” 方向发展，原来的各种模块会被重构
成独立的服务（Service），每个服务（Service）都可以在独立的进程中运行，访问服务（Service）必须使用定义好的接口，通过 IPC
来通信，从而构建一个**更内聚、松耦合、易于维护和扩展的系统**，更好实现 Chrome 简单、稳定、高速、安全的目标。
![未来面向服务的架构 ](https://static001.geekbang.org/resource/image/32/2a/329658fe821252db47b0964037a1de2a.png)

#### TIPS

- Q:为什么还会碰到一些由于单个页面卡死最终崩溃导致所有页面崩溃的情况？

```
有一种情况，叫"同一站点(same-site)"，具体地讲，我们将“同一站点”定义为根域名（例如，geekbang.org）加上协议（例如，https:// 或者http://），还包含了该根域名下的所有子域名和不同的端口，比如下面这三个：
https://time.geekbang.org
https://www.geekbang.org
https://www.geekbang.org:8080
都是属于同一站点，因为它们的协议都是https，而根域名也都是geekbang.org。

Chrome的默认策略是，每个标签对应一个渲染进程。但是如果从一个页面打开了新页面，而新页面和当前页面属于同一站点时，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫process-per-site-instance。即统一站点的页面共用一个渲染进程。

为什么要让他们跑在一个进程里面呢？
因为在一个渲染进程里面，他们就会共享JS的执行环境，也就是说A页面可以直接在B页面中执行脚本。因为是同一家的站点，所以是有这个需求的。
```

- Q:为什么打开一个页面后没有插件也不只四个进程？

```
如果页面里有iframe的话，iframe也会运行在单独的进程中！
```

- Q:Chrome 排版引擎现在是 blink，这一点从哪里可以看到呢？在 76 版本 Chrome 的 navigator 属性值里只看到了 AppleWebkit，这
  是为什么？

```
UserAgent，又称为UA，UA是浏览器的身份证，通常，在发送HTTP请求时，UA会附带在HTTP的请求头中user-agent字段中，这样服务器就会知道浏览器的基础信息，然后服务器会根据不同的UA返回不同的页面内容，比如手机上返回手机的样式，PC就返回PC的样式。

服务器会根据不同的UA来针性的设计不同页面，所以当出了一款新浏览器时，他如果使用自己独一无二的UA，那么之前的很多服务器还需要针对他来做页面适配，这显然是不可能的，比如Chrome发布时他会在他的UA中使用“Mozilla” ，“AppleWebKit”，等关键字段，用来表示他同时支持Mozilla和AppleWebKit，然后再在最后加上他自己的标示，如Chrome/xxx。

这就解释了为什么查看的信息中含有WebKit字样。
```

- 安全沙箱是不能应用到浏览器主进程之上的，因为浏览器主进程需要对操作系统的权限

### 1.2 http

浏览器展示页面，离不开 http 协议，而 http 是基于 tcp 的应用层协议，而 tcp 基于 ip

#### IP

数据包要在互联网上进行传输，就要符合网际协议（Internet Protocol，简称 IP）标准。互联网上不同的在线设备都有唯一的地址，地
址只是一个数字，这个地址就是 IP。

**计算机的地址就称为 IP 地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息**

<p>把一个数据包从主机 A 发送给主机 B，简单的三层网络模型</p>

> IP 头是 IP 数据包开头的信息，包含 IP 版本、源 IP 地址、目标 IP 地址、生存时间等信息。

![简单的三层网络模型](https://static001.geekbang.org/resource/image/00/4d/00d9bcad0bda1fdb43ead428e89ae74d.png)

- 上层将含有“极客时间”的数据包交给网络层；
- 网络层再将 IP 头附加到数据包上，组成新的 IP 数据包，并交给底层；
- 底层通过物理网络将数据包传输给主机 B；
- 数据包被传输到主机 B 的网络层，在这里主机 B 拆开数据包的 IP 头信息，并将拆开来的数据部分交给上层；
- 最终，含有“极客时间”信息的数据包就到达了主机 B 的上层了。

#### UDP

IP 是非常底层的协议，只负责把数据包传送到对方电脑，但是对方电脑并不知道把数据包交给哪个程序，是交给浏览器还是交给英雄联
盟？因此，需要基于 IP 之上开发能和应用打交道的协议，最常见的是“用户数据包协议（User Datagram Protocol）”，简称 UDP。

UDP 中一个最重要的信息是端口号，端口号其实就是一个数字，每个想访问网络的程序都需要绑定一个端口号。

**所以 IP 通过 IP 地址信息把数据包发送给指定的电脑，而 UDP 通过端口号把数据包分发给正确的程序**。和 IP 头一样，端口号会
被装进 UDP 头里面，UDP 头再和原始数据包合并组成新的 UDP 数据包。UDP 头中除了目的端口，还有源端口号等信息。

![简化的 UDP 网络四层传输模型](https://static001.geekbang.org/resource/image/3e/ea/3edb673a43f23d84253c52124ce447ea.png)

下面我们一起来看下一个数据包从主机 A 旅行到主机 B 的路线：

- 上层将含有“极客时间”的数据包交给传输层；
- 传输层会在数据包前面附加上 UDP 头，组成新的 UDP 数据包，再将新的 UDP 数据包交给网络层；
- 网络层再将 IP 头附加到数据包上，组成新的 IP 数据包，并交给底层；
- 数据包被传输到主机 B 的网络层，在这里主机 B 拆开 IP 头信息，并将拆开来的数据部分交给传输层；
- 在传输层，数据包中的 UDP 头会被拆开，并根据 UDP 中所提供的端口号，把数据部分交给上层的应用程序；
- 最终，含有“极客时间”信息的数据包就旅行到了主机 B 上层应用程序这里。

#### TCP

UDP 存在以下不足：

- 数据包在传输过程中容易丢失；
- 大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而 UDP 协议并不知道如
  何组装这些数据包，从而把这些数据包还原成完整的文件。

基于这两个问题，引入 TCP（Transmission Control Protocol，传输控制协议），它是一种面向连接的、可靠的、基于字节 流的传输层
通信协议。相对于 UDP，TCP 有下面两个特点:

- 对于数据包丢失的情况，TCP 提供重传机制；
- TCP 引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。

和 UDP 头一样，TCP 头除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，以便接收端通过序号来重排数据包。

![简化的 TCP 网络四层传输模型](https://static001.geekbang.org/resource/image/94/32/943ac29f7d5b45a8861b0cde5da99032.png)

一个完整的 TCP 连接的生命周期包括了“建立连接”“传输数据”和“断开连接”三个阶段。

##### TCP 建立连接

三次握手建立连接
![三次握手](https://camo.githubusercontent.com/d2ce1b09cab175e3bb53f58161013067bfa7e0df/687474703a2f2f70332e7073746174702e636f6d2f6c617267652f7067632d696d6167652f3135323937343739393637373462333932626366323134)

- 第一次握手： 建立连接。客户端发送连接请求报文段，将 SYN 位置为 1，Sequence Number 为 x；然后，客户端进入 SYN_SEND 状态
  ，等待服务器的确认
- 第二次握手：服务器收到 SYN 报文段。服务器收到客户端的 SYN 报文段，需要对这个 SYN 报文段进行确认，设置 Acknowledgment
  Number 为 x+1(Sequence Number+1)；同时，自己还要发送 SYN 请求信息，将 SYN 位置为 1，Sequence Number 为 y；服务器端将上
  述所有信息放到一个报文段（即 SYN+ACK 报文段）中，一并发送给客户端，此时服务器进入 SYN_RECV 状态
- 第三次握手：客户端收到服务器的 SYN+ACK 报文段。然后将 Acknowledgment Number 设置为 y+1，向服务器发送 ACK 报文段，这个
  报文段发送完毕以后，客户端和服务器端都进入 ESTABLISHED 状态，完成 TCP 三次握手。

简单点讲就是：第一次握手：客户端向服务端发送连接请求；第二次握手：服务端确认连接，并向客户端发送连接请求；第三次握手：客
户端确认连接，三次握手成功

_为什么要三次握手？_

<p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误，所以有第三次客户端确认握手</p>

##### TCP 断开连接

![四次挥手](https://camo.githubusercontent.com/8118d7314aa66510cc96fa3c00207fdc70bb823d/687474703a2f2f70332e7073746174702e636f6d2f6c617267652f7067632d696d6167652f3135323937343739393637343736623165653962323831)

- 第一次挥手： 主机 1（可以使客户端，也可以是服务器端），设置 Sequence Number，向主机 2 发送一个 FIN 报文段；此时，主机
  1 进入 FIN_WAIT_1 状态；这表示主机 1 没有数据要发送给主机 2 了；

- 第二次挥手： 主机 2 收到了主机 1 发送的 FIN 报文段，向主机 1 回一个 ACK 报文段，Acknowledgment Number 为 Sequence
  Number 加 1；主机 1 进入 FIN_WAIT_2 状态；主机 2 告诉主机 1，我“同意”你的关闭请求；

- 第三次挥手： 主机 2 向主机 1 发送 FIN 报文段，请求关闭连接，同时主机 2 进入 LAST_ACK 状态；

- 第四次挥手： 主机 1 收到主机 2 发送的 FIN 报文段，向主机 2 发送 ACK 报文段，然后主机 1 进入 TIME_WAIT 状态；主机 2 收
  到主机 1 的 ACK 报文段以后，就关闭连接；此时，主机 1 等待 2MSL 后依然没有收到回复，则证明 Server 端已正常关闭，那好，
  主机 1 也可以关闭连接了。

简单点讲就是：因为 TCP 是全双工模式，所以断开连接时需要客户端和服务端都要发一次断开连接请求。第一次挥手：客户端发送断开
连接请求；第二次挥手：服务端发送同意断开连接请求给客户端；第三次挥手：服务端发送断开连接请求；第四次挥手：客户端发送同意
断开连接请求给服务端

- _为什么要四次挥手？_

<p>TCP 协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP 是全双工模式，这就意味着，当主机
1 发出 FIN 报文段时，只是表示主机 1 已经没有数据要发送了，主机 1 告诉主机 2，它的数据已经全部发送完毕了；但是，这个时候
主机 1 还是可以接受来自主机 2 的数据；当主机 2 返回 ACK 报文段时，表示它已经知道主机 1 没有数据发送了，但是主机 2 还是可
以发送数据到主机 1 的；当主机 2 也发送了 FIN 报文段时，这个时候就表示主机 2 也没有数据要发送了，就会告诉主机 1，我也没有
数据要发送了，之后彼此就会愉快的中断这次 TCP 连接。</p>
